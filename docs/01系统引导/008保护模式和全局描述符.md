# 保护模式和全局描述符

## 知识点解析

- 保护模式与实模式的不同点

  - 保护模式是计算机长期处于的一个状态，实模式是主引导界面与BIOS硬件自检一些初始化
    - 内存限制：
      - 程序访问内存进行限制，使操作系统和用户空间分割开来，互不干扰，保护内存不被外来程序修改，从而保护内存信息
    - 多进程并发
      - 在实模式下，只能有一个程序运行，在保护模式下，可以进行进程调度，并发运行，
    - IO端口设置
      - 对IO端口进行设置
    - 访存方式不同
      - 实模式只能通过物理实际地址访存，保护模式可以通过虚拟地址函数将虚拟地址映射到物理地址中
      - 虚拟内存映射机制：
        - 操作系统通过虚拟内存映射机制将虚拟地址映射到物理地址，从而使得程序可以在有限的物理内存空间中运行更多的程序。这种映射是通过使用页表或段表等数据结构来完成的，这些数据结构存储了虚拟地址与物理地址之间的映射关系。当程序访问虚拟地址时，操作系统将根据映射关系将其转化为物理地址，并执行相应的内存访问操作。如果虚拟地址对应的物理页没有在内存中，操作系统会将它从磁盘或其他次要存储设备中加载到内存中。这样，虚拟内存实现了程序间的隔离和保护，同时允许操作系统将内存中较少使用的页置换到磁盘上，从而提高内存利用率。
- 保护模式下包括内核态和用户态的代码段
- 全局描述符

  - 用来指明不同内存的不同属性与ARDS类似
  - 内存的起始位置，基地址32位
  - 内存的长度，界限20位
  - 内存属性

    ```cpp

   typedef struct descriptor  // 共8位*/
    {
    unsigned short limit_low;//段界限0~15位
    unsigned int base_low : 24 ;//基地址0~23位16M;
    unsigned char type : 4;//段类型
    unsigned char segment : 1;//1·表示代码段或数据段，0 表示系统段;
    unsigned char DPL : 2;//DescriptorPrivilege Level 描达符特权等级0 ~ 3
    unsigned char present : 1;//存在位，1在内存中，0 在磁盘上;
    unsigned char limit_high :4;//段界限16 ~ 19;
    unsigned char available : 1;//该安排的都安排了，送给操作系统吧
    unsigned char long_mode  :1;//64位扩展标志
    unsigned char big :1;//32位还是16位;
    unsigned char granularity :1;// 粒度 4KB 或1B
    unsigned  char base_high;//基地址 24~31 位
    }__attribute__((packed)) descriptor ;

## type 段类型有4位

 |E| C/D| R/W| A|

- A:是否被cpu访问过，用来判断这部分段需不需要放到磁盘上
- E： 如果为1的话是代码，为0的话是数据，代码是使用数据结构进行的一些算法，数据段的话代表的是一些数据结构

  - 在 E = 1 的情况下
    - C 位代表的是是否是依从代码段//不懂
    - R 位表示是否可读
  - E = 0 的话
    - D：0 向上扩展/1 向下扩展
    - W：是否可写

## 全局描述符与段描述符的区别

- 全局描述符是用来储存段描述符的数据结构
- 全局描述符通常被操作系统内核使用，用于管理和控制内存分段的访问权限和特权级。它是操作系统全局内存管理的一部分。而段描述符则在应用程序和操作系统之间传递，用于描述不同内存段的属性

## 全局描述符表

- 表 - 数组 - 顺序表
- 链表 - 链表
- hash表

```cpp
descriptor gdt[8192]
```

- gdt [0]所有位必须全部为0 -NULL 描述符
- 可用 8191 个描述符

----

## 存储全局描述符的寄存器

- gdtr / 全局描述符表的起始位置和长度

```s
lgdt [gdt_ptr];加载 gdt
sgdt [gdt_ptr];保存 gdt
```

```cpp
typedef struct gdt_ptr
{
  unsigned short limit;// size - 1
  unsigned  int  base; 
}__attribute__((packed)) pointer;
```

## 使用思路

- CPU通过寄存器gdtr和gdt_ptr来找到全局描述符表，再得到全局描述符

## 段选择子

- 是全局描述符表的一个索引，从全局描述符表里取数据段，在程序执行时需要一个代码段和多个数据段 / 栈段 /

```cpp
typedef struct selector
{
  unsigned char  RPL : 2;//表示该段选择子选择的段可以被那些特权级使用
  unsigned char TI :1 ;//判断LDT还是GDT
  unsigned short index : 13;//最多到8092
}__attribute__((packed)) selector;
```

### CPU怎么访问这个段选择子

- 利用段寄存器放入这个 es/ds/cs/ss/fs/gs

## A20线

8086  1M内存

段地址 * 16 + 偏移地址 > 1M
地址回绕：如果得到的物理地址 > 1M 就会取余 1M

打开 A20 线可以实现地址回绕

打开 0x92 端口/寄存器就会打开 A20 线

## 打开保护模式  PE Protect Enable

### 相关的寄存器

- cr0 寄存器第 0 位,置 1
