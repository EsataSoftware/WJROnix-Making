# 汇编知识

## 常用的寄存器

- dx通用寄存器

  - 用于存储16位的数据。在CPU的编程中，DX寄存器常被用于存储数据的内存地址、端口地址、循环计数器以及其他各种用途。它通常与AX寄存器一起使用，来进行数据的传输和操作。在汇编语言程序中，可以使用特定的指令来读取和写入DX寄存器中的值，以完成相应的计算和操作。
- ax通用寄存器

  - AX寄存器是x86架构的CPU中的一个通用寄存器，用于存储16位的数据。它是寄存器组中最常用的寄存器之一，常被用于存放一些重要的数据、操作数和计算结果。在汇编语言程序中，可以使用特定的指令来读取和写入AX寄存器中的值，以完成相应的计算和操作。

  - AX寄存器可以分为两个独立的8位寄存器，即AH（高位）和AL（低位）。AH寄存器用于存储AX寄存器的高8位数据，而AL寄存器用于存储AX寄存器的低8位数据。这种拆分的设计使得AX寄存器在进行8位数据的操作时更加灵活。
- 汇编地址位数解析
  
  - x86是小端存储，靠左位为高位
  - 0b1111与0b0000_1111是等价的
  - 从右到左从0位开始，最右边是最小位

- 特殊例如（段地址）寄存器只能通过通用寄存器来间接赋值，意为先将值放入通用寄存器，再通过通用寄存器来给段地址赋值

## 通用寄存器

  | 寄存器 | 描述 |
  | ------ | ------ |
  |AX | 累加结果数据（accumlator） |
  | BX | 数据段地址指针 （base）|
  |CX | 字符串与循环计数器 （counter）|
  | DX |IO指针  （data）|
  |DI | 目的数据指针 （destination index）|
  | SI | 源数据指针 （source index）|
  | SP | 栈顶指针 （stack point|
  | BP|栈底数据指针（stack point |
  |GDTR|全局描述符的位置|
  |cr0|启用保护模式的寄存器|

## 段寄存器

 | 段寄存器 | 描述 |
  | ------ | ------ |
   | CS | code segment代码段寄存器 |
 | DS |data segment数据段寄存器 |
  |  SS|stack segment栈段寄存器  |
  |ES  |extra segment额外寄存器  |

## 程序状态字

 |名称| 别名 |
| IP | PSW |
 | ------ | ------ |

## 常用指令解析

- out与in指令

  - out 端口号/储存端口号的寄存器，内部寄存器(al/ax)
  - in  内部寄存器(al/ax)，端口号/储存端口号的寄存器  cpu通过端口号找到对应的外部设备的外部寄存器，将外部寄存器的数据传al/ax
- shr指令

  - shr 寄存器，n
  - 将寄存器的数据右移n位
- 逻辑指令

  - and指令
    - 与指令 将每一位进行判断相同为一不同为0，
  - or指令
    - 或指令  
  - xor指令
    - 异或指令
- 跳转指令

  - 无条件跳转

    - jmp指令+.标记   跳转到那个标记
    - jmp 段地址：偏移地址 跳转到这个地址
    - jmp dword xxxx:xxxx  跳转目标地址的大小为32位
    - jmp dword code_selector:0x10000  跳转到
  - 有条件跳转
  
    - jnz指令 判断cmp语句的ZF标志位为0的话执行跳转
    - jz指令 为 1的话执行跳转
    - jc指令 根据CF为选择是否跳转，如果为1的话执行跳转
    - jnc指令 根据CF为选择是否跳转，如果为0的话执行跳转
- 比较指令

  - cmp指令
    - 会将比较的结果存入标志位，一般与条件跳转指令相结合
    - 不仅可以比较寄存器与字符，还可以比较一个内存中的数据不过要指明单位，也就是大小
    - 例 cmp word [0x1000],0x55aa，将存在0x1000区域的字和0x55aa比较

- 系统调用指令

  - int 系统调用号
- 循环指令

  - 根据cx或ecx的值来判断loop的执行次数 ，每次执行就-1，直到cx或ecx值改为0，结束循环
- 自增指令

  - inc reg：递增寄存器的值。
  - inc word [esi] 表示递增 esi 寄存器指向的内存地址中的16位数据。
- 伪指令
  - resb n
  - db  写入一个字节的数据就是8位
  - dw  写入两个字节的数据就是16位
  - dd  写入4个字节的数据就是32位
  - equ 定义字符常量伪指令
  - db RESB指令
    - db 数据 resb大小，申请n个字节写入数据
- mov与movl区别
  
  - mov 目的， 源
  - movl 源，目的

## linux指令

- dd if=loader.bin of=master.img bs=512 count=4 seek=2 conv=notrunc
从第二个扇区开始写4个扇区
- %.bin: %.asm
  - nasm -f bin $< -o $@
  - 模式匹配，不固定文件名，只要是bin与.asm类型的文件在makefile里直接传入

## 如何从主引导区域跳转到内核驱动器
  
- 在进行寄存器配置时，填入硬盘所在的区域以及大小
  - 这一部分是将内核驱动器的代码输出到0x1000区域
  - mov ecx，2 从第2个扇区开始
  - mov bl，4 一共有4个扇区
- 如何实现跳转
  - cmp word [0x1000],0x55aa;判断主引导扇区的正确性
  - jnz error
  - jmp 0:0x1002;跳转到loading文件写入硬盘的区域去执行loading.bin

## 保护模式下的内存管理
  
- 段式内存管理
  - 内存的管理被划分为段式内存管理。每个段都有自己的起始地址和大小，并且被分配给不同的数据或指令。常见的段包括代码段、数据段、栈段、堆段等。

  - 代码段（Code Segment）存储程序的指令。当CPU执行程序时，会从代码段中获取指令并执行。

  - 数据段（Data Segment）存储程序使用的全局变量和静态变量。

  - 栈段（Stack Segment）用于存储函数的局部变量、函数参数和程序执行时的临时数据。栈段是一个特殊的段，它是按照“后进先出”的方式管理数据的，实现了函数的嵌套和递归调用。

  - 堆段（Heap Segment）用于存储动态分配的内存，如通过malloc()和new函数分配的内存空间。

  - 每个段都由一个段描述符来描述，就是全局描述符，段描述符包含了有关段的信息，比如内存地址范围、访问权限、特权级别等。操作系统通过配置段描述符来控制对于不同段的访问权限。

## gcc概述

- gcc（GNU Compiler Collection）是一个由GNU项目开发的编程语言编译器集合。它支持多种编程语言，包括C、C++、Objective-C、Fortran、Ada等。gcc 提供了一种统一的接口，使得用户能够用相同的方式编译不同语言的程序。

## gcc与nasm的异同

  相同点

- 都是语言编译器
   不同点

- gcc一般可以接受的是C与C++等高级语言的编译
- nasm接受的汇编语言的编译
编译汇编代码的过程
- 通过nasm编译成.o 文件，通过gcc再链接到成可执行文件
